index.js
function(传入ID,起始日期,结束日期){
  引入必须的模块;
  连接数据库;
  
  "员工信息表"链接到数据库"员工信息表"
  "班次表"链接到数据库"班次表"
  "考勤组表"链接到数据库"考勤组表"
  "假日表"链接到数据库"假日表"
  "考勤机表"链接到数据库"考勤机表"
  "考勤档案表"链接到数据库"考勤档案表"
  "考勤数据表"链接到数据库"考勤机数据表"
  "手工考勤表"链接到数据库"手工考勤表"
  "调班表"链接到数据库"调班表"
  "补卡记录表"链接到数据库"补卡记录表" 
  "休假类型表"链接到数据库"休假类型表"
  "休假数据表"链接到数据库"休假数据表" 
  "加班类型表"链接到数据库"加班类型表"
  "加班数据表"链接到数据库"加班数据表"
  "出差类型表"链接到数据库"出差类型表"
  "出差数据表"链接到数据库"出差数据表"
  
  var 数据项属性集utoolobj = {//这个字面量的用途在于实时记录当前操作的员工基本信息,后面可能会添加新的内容
  "员工ID" : ID,
  "调班计数器" : number,
  "班次" : 班次,
  "工作时段数量" : number,
  "起始工作时间1" : time,
  "结束工作时间1" : time,
  "起始工作时间2" : time,
  "结束工作时间2" : time,
  "起始工作时间3" : time,
  "结束工作时间3" : time,//可以根据实际情况添加
  "弹性工作时段标记" : "101",
  ""
  "工作区间数段标记" : "110"//这个标记目的在于记录一天的区段存在与否，其意义按照字符数组下标的奇偶对应为--偶->上班 奇->下班
  }
  
  员工总数 = 符合传入ID的人员总数(部门,人员类别,考勤方式)
  日报表行数 = 员工总数*(结束日期 - 起始日期 + 修正加一天);//法定假日不显示？
  
  创建空表单日报表输出表单
  为表单添加属性
  
  员工名单 = 符合传入ID的人员报表
  
  for(遍历员工名单每个人){
    for(遍历起止日期每一天){
	向日报表写入基本信息
	}
  }
  dailyDeal();
  event();
 
}

event(){
//包含- 法定假,休假,出差,加班,销假,正常数据
	  
	//由于一天存在很多工作时段，所以请假会出现很多种情况，不过这里只考虑请假按照时段来请
    //即不存在工作时间内请假，后面会补上这个功能
    //这里要设置一个用于标记每个时段状态的数组，数组长度由班次的时段数量决定
    //每一个字面量数组元素包含内容如下：
    // status = {
	//            "正常" ：yes or no,
    //            "异常" ：erobj = {
	//                                "迟到" ：yes or no,
	//                                "早退" ：yes or no,
	//                                "旷工半天" ：yes or no
	//                             }
    //            "休假" ：yes or no,
    //            "出差" ：yes or no,
	//            "法定假"：yes or no,
    //            "时长" ：last = {
	//                                "工作时长" ：hour,
	//                                "休假时长" : hour,
	//                                "出差时长" : hour,
	//                                "早退时长" : hour,
	//                                "迟到时长" : hour,
	//                                "弹性迟到时长" : hour//这个可以舍去,没用了
    //                            }	
    //          }
    
	for(遍历每一个人)
	{
	  设置utoolobj
		
	  总休假标记 = 数据库存在此人在规定日期内的休假记录 
	  总出差标记 = 数据库存在此人在规定日期内的出差记录
	  总加班标记 = 数据库存在此人在规定日期内的加班记录
	  总销假标记 = 数据库存在此人在规定日期内的销假记录
	  
	  for(遍历每一天)
	  {
	    if(调班计数器至0)
        {//确定调班不会影响后面的代码正确执行
          使用"调班表"重置班次等属性
          if("调班表"中无大于当前循环日期的调班)
		  {
	      调班计数器值调整为循环剩余天数
	      }else{
	      调班计数器调整为距下次调班的天数
	      }
		}
		
	    初始化状态数组
		
	    if(当天为法定节假日 & 班次为"正常休假")
		{//首先解决法定假日的问题
		  for(状态数组长度)
		  {
		    所有"法定假" 置 yes
		  }
		}
		
		//注意，由于判断当天工作时段的状态时，使用的是时段的区间判断方法，所以没有将跨天特殊情况进行分解，分解了也不好算。
				
		休假开始时间
		休假结束时间
		
		出差开始时间
		出差结束时间
		
		加班开始时间
		加班结束时间
		加班总时长
		
	
		
		for(当天时段段数)
		{
		  计数器n
		  
		  if(总休假标记)
		  {//休假.简化数据库操作
		    if(休假标记)
			{//进行到这一步，说明当天有休假，且可能不只有一次
		      (function休假(){
		       //执行当前时段的休假判断

			   for(休假标记)
			   {
			     计数器m
				 //此处可录入休假的起止时间到报表
				 修剪、补齐休假起始时间和休假结束时间（这是个函数，参数为当前日期，时段起止时间，休假起止时间，补齐参数）
				 //注意：返回值（日期）可能为0，寓意当前时段与休假没有重叠部分，话句话说就是这个时段没有休假
				 
				 if(修建后的休假起止时间不为0)
				 {
				   置当前位置的status为"休假"=yes
				 }
				 
				 //此处可录入休假的精确的起止时间到报表，后面的出差、加班是相同的
				 status -> 休假时长 += 休假结束时间 - 休假开始时间
		       }
		      }()
		  
		    }
		  }
		  
		  if(总销假标记)
		  {
		    if(销假标记)
			{//进行到这一步，说明当天有销假，且可能不只有一次
		      (function销假(){
		       //执行当前时段的销假判断
		       
			   for(销假标记)
			   {
			     计数器m
				 
				 修剪、补齐销假起始时间和结束时间
				 //重复休假在此处被削去重叠
				 休假总时长 -= 销假结束时间 - 销假开始时间
		       }
		      }()
		  
		    }
		  }
		  
		  if(总出差标记)
		  {
		    if(出差标记)
			{//进行到这一步，说明当天有出差，且可能不只有一次
		      (function出差(){
		       //执行当前时段的出差判断
		       
			   for(出差标记)
			   {
			     计数器m
				 
				 修剪、补齐出差起始时间和结束时间
				 
				 if(修建后的休假起止时间不为0)
				 {
				   置当前位置的status为"出差"=yes
				 }
				 
			     status -> 出差时长 = 结束出差时间 - 起始出差时间
		       }
		      }()
		  
		    }
		  }
		  
		  //当下时段的"正常""异常"判断
		  //涉及到迟到早退旷工的问题，需讨论再能决定怎么算
		   
		  (function正常上班(){//按理来说,弹性及时长的判断应该在这里完成
		  //这部分用于处理时段的迟到旷工早退的问题
			 
			  if(当前上班刷卡时间存在 & 当前上班刷卡时间存在)//有刷卡记录
			  {
			  if(当前时段上班刷卡时间 - 允许迟到?允许迟到最长分钟:0 > 标准上班时间)//迟到判断
			  {//后面检查是否是休假或出差导致迟到
			    if(休假结束时间 + 休假接受刷卡范围 > 当前上班刷卡时间 > 休假结束时间 - 休假接受刷卡范围)
				{//这里特别说明:前面考虑到了一个时段内休假或出差两次,所以此处的判断理应也用循环来判断,下面也是一样
				  正常
				}else if(出差结束时间 + 出差接受刷卡范围 > 当前上班刷卡时间 > 出差结束时间 - 出差接受刷卡范围)
				{
				  正常
				}else
				{//没有出差,休假的影响,或有出差休假,但又没有在合适的时间内刷卡,判断为迟到
				
			    status -> "迟到" = yes
				status -> 迟到时长 = 当前上班刷卡时间 - (标准上班时间 + 允许迟到?允许迟到分钟:0)
				}
			  }
			 
			  if(当前时段下班刷卡时间 + 允许早退?允许早退最长分钟:0 < 标准下班时间)//早退判断
			  {//后面检查是否是休假或出差导致早退
			    if(休假开始时间 + 休假接受刷卡范围 > 当前下班刷卡时间 > 休假开始时间 - 休假接受刷卡范围)
				{
				  正常
				}else if(出差开始时间 + 出差接受刷卡范围 > 当前下班刷卡时间 > 出差开始时间 - 出差接受刷卡范围)
				{
				  正常
				}else
				{//没有出差,休假的影响,或有出差休假,但又没有在合适的时间内刷卡,判断为早退
				
			    status -> "早退" = yes
				status -> 早退时长 =  (标准下班时间 - 允许迟到?允许迟到分钟:0) - 当前下班刷卡时间
				}
			  }
			  
			  if(当前时段是弹性的)
			  {//弹性工作制下的工作时长
			    if(当前时段为第一个时段)
				{//这里把第一个数段单独拿出来
				 //因为第一个时段负责检测整天的上下班的弹性情况,作为整体需要考虑的数据,放在循环外面来判断
				}else
				{
				    if(下班标准时间n-1 存在)
					{//若不存在,则说明上个时段出差,休假或者旷工,记录弹性时间没有意义
				    if(下班标准时间n-1 - 取值区间(人为规定) 到 上班标准时间 + 取值区间 有两个以上的刷卡数据)
					{//要是只有一个则说明必定迟到早退,上面的逻辑会判断出来的
					   取刷卡数据两端的(离两个修正标准时间最近)刷卡数据
					   俩刷卡时间间距 > 休息时间(这个从utoolobj中取)
					   if(迟到 == no)
					   {//若迟到已经存在,弹性时间的迟到毫无意义
					     status -> 迟到 = yes
						 status -> 迟到时间 = 两刷卡时间间距 - 休息时间
					   }
					}
					}
				}
			  }
			  
			  if((status -> 迟到时长 > 迟到记全天旷工)) ||
			     (status -> 早退时长 > 早退记全天旷工))  )//全天旷工判断
			  {
			     for(所有字面量)
				 {
				 status -> "半天旷工" = yes
				 }
			  }
			  
			  if((status -> 迟到时长 > 迟到记半天旷工)) ||
			     (status -> 早退时长 > 早退记半天旷工))  )//半天旷工判断
			  {
			     status -> "半天旷工" = yes
			  }
			  
		      }else{
			  //没有上班或者下班的数据或者全没有
			  //那么三种可能
			  //1.休假休了整个时段 2.出差出了整个时段 3.旷工
			  if(休假起止时间与时段起止时间重合 || 出差起止时间与时段起止时间重合)
			  {
			    正常
			  }else{
			    status -> "全天旷工" = yes
			  }
			  }
		  })()
		 
		}
		
	      if(总加班标记)//加班每天就一次，不进入循环
		  {
		    if(加班标记)
			{
		      (function加班(){
		       //执行当前时段的加班判断
		       
			   加班时间 = 刷卡时间 - 加班开始时间
			   
			   if(加班时间 <=0)
			   {
			     抛出加班无效
			   }
			   
			   if(加班结束时间 <= 当前下班时间)//这里较为严格
			   {
			   //添加完成加班的操作
			   }
		      }()
		  
		    }
		  }
		  
		
		//所有状态判断结束,下面开始使用状态生成最终数据
		
		工作开始时间
		未获取工作开始时间 = true
		工作结束时间
		
		for(字面量数组长度)
		{//获取工作开始与结束时间
		  计数器n
		//首先判断工作开始与结束时间，这里参考已有的系统方法，工作时长采用前后相减
		  
		  if(未获取工作开始时间 & 当前时段起始工作时间存在)
		  {
		    工作开始时间 = 当前时段起始工作时间存在
			未获去工作开始时间 = false
		  }
		  
		  if(未获取工作结束时间 & 当前时段结束工作时间存在)
		  {
		    工作结束时间 = 当前时段结束工作时间
		  }
		}
		
		输出工作开始时间，工作结束时间到数据库//虽然这个开始与结束时间没什么实际用处,但是写上去让人看看还是应该的
		
		时长计算始点 = 弹性?(字面量0中起始刷卡时间存在?起始刷卡时间:标准上班时间):标准上班时间
		时长计算终点 = 弹性?(字面量n-1中结束刷卡时间存在?结束刷卡时间:标准下班时间):标准下班时间
		工作时长 = 时长计算始点 - 时长计算终点
		迟到时长
		早退时长
		休假时长
		出差时长
		
		for(字面量数组长度)//处理最后的时长问题
		{
		  计数器n
		  if(旷工半天)
		  {
		    工作时长 -= 标准下班时间n - 标准上班时间n 
		    continue
		  }
		  
		  if(迟到)
		  {
		    工作时长 -= 迟到时长n
			迟到时长 += 迟到时长n
		  }
		  
		  if(早退)
		  {
		    工作时长 -= 早退时长n
			早退时长 += 早退时长n
		  }
		  出差时长 += 出差时长n
		  休假时长 += 休假时长n
		}
		
		//这里所有需要显示的计算都已完成,下面怎么显示则需要根据要求(工作时长,休假时长,迟到早退时长,出差时长,加班时长迟到)显示
		输入到数据库
	  }
	  
	  
    }
 
}


dailyDeal(){
 
  for(遍历员工名单每个人)
  {
    设置utoolobj
	
  for(起止日期内)
  {
  
  if(调班计数器至0)
  {//为方便用调班与当前班次判断使用的数据班次，建议使用日期倒序方式遍历数据
  
    使用"调班表"重置班次等属性
	
    if("调班表"中无大于当前循环日期的调班){
	调班计数器值调整为循环剩余天数
	}else{
	调班计数器调整为距下次调班的天数
	}
  }
  
  /***********************************************
  *用户可能在同一天，对于不同时段对区间的要求不同*
  *以早班、上中晚三段工作时段为例，可能早上用户要*
  *求需要有打卡区间来防止过早到过晚退，但是中午则*
  *没有这个要求，只要有打卡记录就可以，这个时候缺*
  *省值应当设为距离最近的打卡标准时间。          *
  *同样的对于弹性也有相同的非常规要求，如何更好的*
  *定义缺省需要思考。
  ***********************************************/
  
  //当前使用方法为：先根据区段获取刷卡节点，获取不到就算了
  //由于每个区段存在不同的可能，所以要根据工作区间是否存在的
  //标记来决定取数方式
  //总的判断结构如下：
  //是否跨天{是否存在区间{上班还是下班{是否有记录}}}
  //这里的判断基本单元是一个时段的上下班某一个时间点
  
  for(工作区间数段标记长度){
  设置计数器
  跨天日期回溯 = 是否跨天 //这一参数用途体现在获取刷卡数据上，所以在后面的算法中体现不出来，跨天默认到前一天的中午十二点
  
  
  if(当前工作区间标记 == "1"){
  
  //说明当前存在工作区间，取数应当在此区间内取值，但是要注意，对于一个标准节点来说，有左区间未必有右区间，
  //比如上班只有左区间，这时如果左区间没有数据，右边如何取数是个大问题。原则上应当按照最有利与员工的原则，
  //解答：右边给出一个确定的缺省区间，缺省区间内取值按照最近原则，对于可能的冲突如下：
  //1.一时段内的左右两端标准时间点在其优先取点区域内找不到，进而在时段内取点，这时时段内只有一个点。按照先来先得的规则。
  //2.不同时段之间的标准时间点取值区域无区间约束，并且只有一个点。按照先来先得的规则。
  //
  

	if(计数器为偶数)//上班时间
	{
	  if(数据库操作.存在位于起始工作时间之间n和左边界的刷卡记录)//时段左边的区段取数，按先左后右的方法
	  {
	   取距离时段标准上班时间最（近）的刷卡记录
	   记录到数据库
	   continue
	  }else if(数据库操作.存在位于起始工作时间之间n和结束工作时间n的刷卡记录){
	  //这里的模式并不确定
	  
	   取距离起始工作时间最（近）的刷卡记录
	   记录到数据库
	   continue
	  }
	}
	
	if(计数器为奇数)//下班时间
	{
	  if(数据库操作.存在位于结束工作时间n和右边界之间的刷卡记录)
	  {//时段右边的区段取数，按先右后左的放
	  
	   if(计数器 为 工作区间数段标记长度 - 1){
	   //说明这是当天班次的最后下班时间，要考虑取数模式
	   取距离结束工作时间最（近/远）的刷卡记录
	   }else{
	   取距离结束工作时间最（远/近）的刷卡记录
	   }
	   记录到数据库
	   continue
	  }else if(数据库操作.存在位于结束工作时间n和起始工作时间之间n的刷卡记录)
	  {//发生冲突了
	  
	   取距离结束工作时间最（近）的刷卡记录
	   if(下班刷卡记录 == 上班刷卡记录)
	   {//这里加入判断原则
	   
	   }
	   记录到数据库
	  }
	}
  }else if(当前工作区间标记 == "0")
  {//这里要说明以下，一般情况下，无论是纯弹性还是半弹性还是无弹性，"上班有效刷卡区间"和"下班有效刷卡区间"都必然存在
  
    if(计数器 == "0" 或者 计数器 == 工作区间数段标记长度 - 修正减一)
	{
	   抛出错误：未设置上班下班区间
	   exit
	}else{
	   if(计数器为偶数)//上班时间
	{
	  if(数据库操作.存在位于开始工作时间n和结束工作时间n-1之间的刷卡记录)//缺省使用上个时段下班时间
	  {
	   取距离时段标准上班时间最近的刷卡记录
	   记录到数据库
	  }else if(数据库操作.存在位于开始工作时间n和结束工作时间n之间的刷卡记录){
	   取距离时段标准上班时间最近的刷卡记录
	   记录到数据库
	  }
	}
	
	if(计数器为奇数)//下班时间
	{
	  if(数据库操作.存在位于结束工作时间n和开始工作时n+1的刷卡记录)
	  {
	  if(下班刷卡记录n == 上班刷卡记录n+1)
	   {//这里加入判断原则
	   
	   }
	   记录到数据库
	  }else if(数据库操作.存在位于结束工作时间n和开始工作时间n之间的刷卡记录)
	  {
	    if(下班刷卡记录n == 上班刷卡记录n)
	   {//这里加入判断原则
	   
	   }
	   取距离时段标准下班时间最近的刷卡记录
	   记录到数据库
	  }
	}
    } } } } 
	
	for(补卡表所有的记录)
	{//考虑补卡的时间一定会落在上班的时段内，且一般补卡都是直接使用的，所以这里不考虑补卡无意义的情况//
	  一次补卡记录时间个数
	  
	  //需要检验该员工在这个记录的日期节点中的班次是什么
		//所以需要考虑调班、
		
		设置班次为员工当前班次
		if(员工在报表日期长度内有调班记录)
		{
		   for(按日期从大到小遍历记录个数)
           {
              计数器n
			  if(补卡日期 比 调班日期大)
			  {//补卡班次为当前调班后的班次，不用改了
				break
			  }else{
			   //补卡班次不是当前员工班次
			    补卡 = 调班前班次
			  }
           }
		   
		}
	  
	  for(补卡记录时间个数)
	  {
	    计数器n
		
		
		for(当天时段段数)
		{
		  计数器m
		  
		  if(补卡记录时间n 落在 时段起始工作时间m 和 结束工作时间m 之间)
		  {//说明是补得这个时段内的卡，但是仍不确定是补得上班卡还是下班卡
		    
			if(补卡记录时间n 到 起始工作时间m的时长 大于 补卡记录时间n 到 结束工作时间m的时长)
			{//说明补卡时间离上班时间比较近，这里就直接判定为上班的补卡
			  记录该上班补卡记录到数据库
			}else{
			  记录该下班补卡记录到数据库
	        }
		  }
		}
	  }
	
	
	}
	
	
	}
}

  
  


	
  

